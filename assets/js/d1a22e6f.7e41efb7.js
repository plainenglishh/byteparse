"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[868],{2463:e=>{e.exports=JSON.parse('{"functions":[{"name":"set_capacity","desc":"Resizes the internal buffer to a given size.\\n\\n    ","params":[{"name":"new_size","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":274,"path":"lib/init.luau"}},{"name":"expand","desc":"Ensures the internal buffer can handle `extra_size` more data by \\nexpanding the capacity if necessary.\\n\\nResizes relative to the cursor.\\n\\n    ","params":[{"name":"extra_size","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":288,"path":"lib/init.luau"}},{"name":"advance_write","desc":"Advances the write cursor by a set amount following a write.\\nUpdates the written_size accordingly.\\n\\n    ","params":[{"name":"offset","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","ignore":true,"source":{"line":302,"path":"lib/init.luau"}},{"name":"set_cursor","desc":"Sets the write cursor to a given position.\\n\\n    ","params":[{"name":"position","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":315,"path":"lib/init.luau"}},{"name":"get_cursor","desc":"Returns the current cursor position.\\n\\n    ","params":[],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"static","source":{"line":324,"path":"lib/init.luau"}},{"name":"get_size","desc":"Returns the current written size.\\n\\n    ","params":[],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"static","source":{"line":333,"path":"lib/init.luau"}},{"name":"get_capacity","desc":"Returns the internal buffer capacity.\\n\\n    ","params":[],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"static","source":{"line":342,"path":"lib/init.luau"}},{"name":"set_default_vector_size","desc":"Sets the vector size. The given vector size cannot exceed the VMs\\n\'LUA_VECTOR_SIZE\' size.\\n\\n    ","params":[{"name":"vec_size","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","errors":[{"lua_type":"InvalidVecSize","desc":"Errors when passed a vector size that isn\'t 3 or 4."}],"source":{"line":359,"path":"lib/init.luau"}},{"name":"to_buffer","desc":"Returns a buffer containing the written data.\\n    ","params":[],"returns":[{"desc":"","lua_type":"buffer\\r\\n"}],"function_type":"static","source":{"line":370,"path":"lib/init.luau"}},{"name":"to_string","desc":"Returns a string containing the written data.\\n    ","params":[],"returns":[{"desc":"","lua_type":"string\\r\\n"}],"function_type":"static","source":{"line":379,"path":"lib/init.luau"}},{"name":"write_u8","desc":"Writes an unsigned 8 bit integer. Wraps around if provided a number\\nlarger than 8 bits.\\n    ","params":[{"name":"value","desc":"","lua_type":"u8"}],"returns":[],"function_type":"static","source":{"line":387,"path":"lib/init.luau"}},{"name":"write_u16","desc":"Writes an unsigned 16 bit integer. Wraps around if provided a number\\nlarger than 16 bits.\\n    ","params":[{"name":"value","desc":"","lua_type":"u16"}],"returns":[],"function_type":"static","source":{"line":397,"path":"lib/init.luau"}},{"name":"write_u32","desc":"Writes an unsigned 32 bit integer. Wraps around if provided a number\\nlarger than 32 bits.\\n    ","params":[{"name":"value","desc":"","lua_type":"u32"}],"returns":[],"function_type":"static","source":{"line":407,"path":"lib/init.luau"}},{"name":"write_i8","desc":"Writes an unsigned 8 bit integer. Wraps around if provided a number\\nlarger than 8 bits.\\n    ","params":[{"name":"value","desc":"","lua_type":"i8"}],"returns":[],"function_type":"static","source":{"line":417,"path":"lib/init.luau"}},{"name":"write_i16","desc":"Writes an unsigned 16 bit integer. Wraps around if provided a number\\nlarger than 16 bits.\\n    ","params":[{"name":"value","desc":"","lua_type":"i16"}],"returns":[],"function_type":"static","source":{"line":427,"path":"lib/init.luau"}},{"name":"write_i32","desc":"Writes an unsigned 32 bit integer. Wraps around if provided a number\\nlarger than 32 bits.\\n    ","params":[{"name":"value","desc":"","lua_type":"i32"}],"returns":[],"function_type":"static","source":{"line":437,"path":"lib/init.luau"}},{"name":"write_f32","desc":"Writes a 32 bit floating point number. Wraps around if provided a number\\nlarger than 32 bits.\\n    ","params":[{"name":"value","desc":"","lua_type":"f32"}],"returns":[],"function_type":"static","source":{"line":447,"path":"lib/init.luau"}},{"name":"write_f64","desc":"Writes a 64 bit floating point number.\\n    ","params":[{"name":"value","desc":"","lua_type":"f64"}],"returns":[],"function_type":"static","source":{"line":456,"path":"lib/init.luau"}},{"name":"write_varint","desc":"Writes a ProtoBuf [Base 128 Variable-width integer](https://protobuf.dev/programming-guides/encoding/#varints).\\n    ","params":[{"name":"value","desc":"","lua_type":"varint"}],"returns":[],"function_type":"static","source":{"line":465,"path":"lib/init.luau"}},{"name":"write_bool","desc":"Writes a boolean.\\n    ","params":[{"name":"value","desc":"","lua_type":"boolean"}],"returns":[],"function_type":"static","source":{"line":479,"path":"lib/init.luau"}},{"name":"write_null","desc":"Writes a null byte.\\n    ","params":[],"returns":[],"function_type":"static","source":{"line":486,"path":"lib/init.luau"}},{"name":"write_string","desc":"Writes a string without a prefixed length, optionally trimmed/padded to \\na given size.\\n\\nNote: You should ensure the binary format has a way of encoding the\\nstrings size, as this function writes the string raw and doesn\'t write\\nany data a reader can use to determine the size.\\n    ","params":[{"name":"value","desc":"","lua_type":"string"},{"name":"size","desc":"","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":498,"path":"lib/init.luau"}},{"name":"write_lstring","desc":"Writes a length prefixed string.\\n    ","params":[{"name":"value","desc":"","lua_type":"string"},{"name":"size","desc":"","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":515,"path":"lib/init.luau"}},{"name":"write_zstring","desc":"Writes a null terminated (C Style) string. \\n\\nWhen passed `size`, trims the string to `size` or pads the end with zeros.\\nThe `size` parameters specifies the length of the string buffer, and\\nincludes the null-terminator.\\n\\n:::warning\\nThis function doesn\'t check whether the passed value is null-safe, and\\nwill write the entire string regardless of embedded null bytes.\\n\\nConsider wrapping the passed value with `byteparse.trim_zstring` if you\\ncan\'t be sure there are no embedded null bytes.\\n:::\\n    ","params":[{"name":"value","desc":"","lua_type":"string"},{"name":"size","desc":"","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":536,"path":"lib/init.luau"}},{"name":"write_buffer","desc":"Writes a buffer without a prefixed length, optionally trimmed or null\\npadded to to a specified size.\\n\\nNote: You should ensure the binary format has a way of encoding the\\nbuffers size, as this function writes the buffer raw and doesn\'t write\\nany data a reader can use to determine the size.\\n    ","params":[{"name":"value","desc":"","lua_type":"buffer"},{"name":"offset","desc":"","lua_type":"number?"},{"name":"size","desc":"","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":552,"path":"lib/init.luau"}},{"name":"write_lbuffer","desc":"Writes a length prefixed buffer.\\n    ","params":[{"name":"value","desc":"","lua_type":"buffer"},{"name":"offset","desc":"","lua_type":"number?"},{"name":"size","desc":"","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":570,"path":"lib/init.luau"}},{"name":"write_zbuffer","desc":"Writes a null terminated (C Style) buffer.\\n\\nAssumes the buffer is null safe.\\n\\n:::warning\\nThis function doesn\'t check whether the passed value is null-safe, and\\nwill write the entire buffer regardless of embedded null bytes.\\n\\nConsider wrapping the passed value with `byteparse.trim_zbuffer` if you\\ncan\'t be sure there are no embedded null bytes.\\n:::\\n    ","params":[{"name":"value","desc":"","lua_type":"buffer"},{"name":"offset","desc":"","lua_type":"number?"},{"name":"size","desc":"","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":589,"path":"lib/init.luau"}},{"name":"write_array","desc":"Writes a array without a prefixed length.\\n\\nAssumes the writer_callback function advances the cursor.\\n\\nNote: You should ensure the binary format has a way of encoding the\\narrays size, as this function doesn\'t write any data a reader can use\\nto determine the size.\\n\\n    ","params":[{"name":"value","desc":"","lua_type":"{T}"},{"name":"writer_callback","desc":"","lua_type":"(T) -> ()"},{"name":"...","desc":"Additional parameters to pass to the writer_callback.","lua_type":"B..."}],"returns":[],"function_type":"static","source":{"line":604,"path":"lib/init.luau"}},{"name":"write_larray","desc":"Writes a length prefixed array.\\n\\nAssumes the writer_callback function advances the cursor.\\n\\n    ","params":[{"name":"value","desc":"","lua_type":"{T}"},{"name":"writer_callback","desc":"","lua_type":"(T) -> ()"},{"name":"...","desc":"Additional parameters to pass to the writer_callback.","lua_type":"B..."}],"returns":[],"function_type":"static","source":{"line":617,"path":"lib/init.luau"}},{"name":"write_zarray","desc":"Writes a null terminated array.\\n\\nAssumes the writer_callback function advances the cursor. The writer_callback function\\ncan freely emit null bytes **after** the first byte, provided it advances the cursor properly.\\n\\n    ","params":[{"name":"value","desc":"","lua_type":"{T}"},{"name":"writer_callback","desc":"","lua_type":"(T) -> ()"},{"name":"...","desc":"Additional parameters to pass to the writer_callback.","lua_type":"B..."}],"returns":[],"function_type":"static","source":{"line":630,"path":"lib/init.luau"}},{"name":"write_vector","desc":"Writes a vector.\\n    ","params":[{"name":"value","desc":"","lua_type":"vector"},{"name":"vector_size","desc":"","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":638,"path":"lib/init.luau"}},{"name":"write_table","desc":"Writes a serialisable table.\\n    ","params":[{"name":"value","desc":"","lua_type":"SerialisableTable"}],"returns":[],"function_type":"static","source":{"line":651,"path":"lib/init.luau"}},{"name":"write_any","desc":"Writes any serialisable type, with the Luau TValue prefixed.\\n    ","params":[{"name":"value","desc":"","lua_type":"Serialisable"}],"returns":[],"function_type":"static","source":{"line":683,"path":"lib/init.luau"}},{"name":"write_optional","desc":"Writes an optional value.\\n\\nThis function writes a boolean indicating whether the value is present,\\nfollowed by the data itself (if present) using `writer_callback`.\\n\\n#### Example Use\\n```lua\\nwriter.write_optional(1, writer.write_u8); -- Writes `0101`\\nwriter.write_optional(nil, writer.write_u8); -- Writes `00`\\n```\\n    ","params":[{"name":"value","desc":"","lua_type":"T?"},{"name":"writer_callback","desc":"","lua_type":"(T) -> ()"},{"name":"...","desc":"","lua_type":"B..."}],"returns":[],"function_type":"static","source":{"line":719,"path":"lib/init.luau"}}],"properties":[],"types":[],"name":"writer","desc":"Writer instance used to serialise to binary formats.\\n    ","source":{"line":267,"path":"lib/init.luau"}}')}}]);