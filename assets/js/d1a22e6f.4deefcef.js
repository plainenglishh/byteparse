"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[868],{2463:e=>{e.exports=JSON.parse('{"functions":[{"name":"set_capacity","desc":"Resizes the internal buffer to a set amount.\\n\\n    ","params":[{"name":"to","desc":"The new size.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":211,"path":"lib/init.luau"}},{"name":"expand","desc":"Ensures the internal buffer can handle `needed_size` more data by \\nexpanding the capacity if necessary.\\n\\nRelative to the cursor.\\n\\n    ","params":[{"name":"needed_size","desc":"The size amount needed.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":226,"path":"lib/init.luau"}},{"name":"advance_write","desc":"Advances the write cursor by a set amount following a write.\\nSets the written_size accordingly.\\n\\n    ","params":[{"name":"by","desc":"How much to advance the cursor.","lua_type":"number"}],"returns":[],"function_type":"static","ignore":true,"source":{"line":241,"path":"lib/init.luau"}},{"name":"set_cursor","desc":"Sets the write cursor to a set position.\\n\\n    ","params":[{"name":"to","desc":"The position to move to.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":255,"path":"lib/init.luau"}},{"name":"get_cursor","desc":"Gets the current cursor position.\\n\\n    ","params":[],"returns":[{"desc":"The cursor position.","lua_type":"number"}],"function_type":"static","source":{"line":265,"path":"lib/init.luau"}},{"name":"get_size","desc":"Gets the current written size.\\n\\n    ","params":[],"returns":[{"desc":"The current written size.","lua_type":"number"}],"function_type":"static","source":{"line":275,"path":"lib/init.luau"}},{"name":"get_capacity","desc":"Returns the internal buffer capacity.\\n\\n    ","params":[],"returns":[],"function_type":"static","source":{"line":284,"path":"lib/init.luau"}},{"name":"set_vector_size","desc":"Sets the vector size. The given vector size cannot exceed the VMs\\n\'LUA_VECTOR_SIZE\' size.\\n\\n    ","params":[{"name":"to","desc":"The vector size, must be either 3 or 4.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":302,"path":"lib/init.luau"}},{"name":"to_buffer","desc":"Returns a buffer containing the written data.\\n\\n    ","params":[],"returns":[{"desc":"The written data.","lua_type":"buffer"}],"function_type":"static","source":{"line":315,"path":"lib/init.luau"}},{"name":"to_string","desc":"Returns a string containing the written data.\\n\\n    ","params":[],"returns":[{"desc":"","lua_type":"buffer"}],"function_type":"static","source":{"line":326,"path":"lib/init.luau"}},{"name":"write_u8","desc":"Writes an unsigned 8 bit integer. Wraps around if provided a number\\nlarger than 8 bits.\\n\\n    ","params":[{"name":"value","desc":"The u8 value to write.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":336,"path":"lib/init.luau"}},{"name":"write_u16","desc":"Writes an unsigned 16 bit integer. Wraps around if provided a number\\nlarger than 16 bits.\\n\\n    ","params":[{"name":"value","desc":"The u16 value to write.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":348,"path":"lib/init.luau"}},{"name":"write_u32","desc":"Writes an unsigned 32 bit integer. Wraps around if provided a number\\nlarger than 32 bits.\\n\\n    ","params":[{"name":"value","desc":"The u32 value to write.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":360,"path":"lib/init.luau"}},{"name":"write_i8","desc":"Writes an unsigned 8 bit integer. Wraps around if provided a number\\nlarger than 8 bits.\\n\\n    ","params":[{"name":"value","desc":"The i8 value to write.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":372,"path":"lib/init.luau"}},{"name":"write_i16","desc":"Writes an unsigned 16 bit integer. Wraps around if provided a number\\nlarger than 16 bits.\\n\\n    ","params":[{"name":"value","desc":"The i16 value to write.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":384,"path":"lib/init.luau"}},{"name":"write_i32","desc":"Writes an unsigned 32 bit integer. Wraps around if provided a number\\nlarger than 32 bits.\\n\\n    ","params":[{"name":"value","desc":"The i32 value to write.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":396,"path":"lib/init.luau"}},{"name":"write_f32","desc":"Writes a 32 bit floating point number. Wraps around if provided a number\\nlarger than 32 bits.\\n\\n    ","params":[{"name":"value","desc":"The f32 value to write.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":408,"path":"lib/init.luau"}},{"name":"write_f64","desc":"Writes a 64 bit floating point number.\\n\\n    ","params":[{"name":"value","desc":"The f64 value to write.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":419,"path":"lib/init.luau"}},{"name":"write_varint","desc":"Writes a ProtoBuf [Base 128 Variable-width integer](https://protobuf.dev/programming-guides/encoding/#varints).\\n    \\n    ","params":[{"name":"value","desc":"The varint to write.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":430,"path":"lib/init.luau"}},{"name":"write_bool","desc":"Writes a boolean.\\n\\n    ","params":[{"name":"value","desc":"The boolean to write.","lua_type":"boolean"}],"returns":[],"function_type":"static","source":{"line":446,"path":"lib/init.luau"}},{"name":"write_null","desc":"Writes a null byte.\\n    ","params":[],"returns":[],"function_type":"static","source":{"line":453,"path":"lib/init.luau"}},{"name":"write_string","desc":"Writes a string without a prefixed length, optionally trimmed to a \\nmaximum size.\\n\\nNote: You should ensure the binary format has a way of encoding the\\nstrings size, as this function writes the string raw and doesn\'t write\\nany data a reader can use to determine the size.\\n\\n    ","params":[{"name":"value","desc":"The string to write.","lua_type":"string"},{"name":"size","desc":"The maximum size of the string.","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":468,"path":"lib/init.luau"}},{"name":"write_lstring","desc":"Writes a length prefixed string.\\n\\n    ","params":[{"name":"value","desc":"The string to write.","lua_type":"string"},{"name":"size","desc":"The maximum size of the string.","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":482,"path":"lib/init.luau"}},{"name":"write_zstring","desc":"Writes a null terminated (C Style) string. \\n\\n:::warning\\nThis function doesn\'t check whether the passed value is null-safe, and\\nwill write the entire string regardless of embedded null bytes.\\n\\nConsider wrapping the passed value with `byteparse.trim_zstring` if you\\ncan\'t be sure there are no embedded null bytes.\\n:::\\n\\n    ","params":[{"name":"value","desc":"The string to write.","lua_type":"string"},{"name":"size","desc":"The maximum size of the string.","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":502,"path":"lib/init.luau"}},{"name":"write_buffer","desc":"Writes a buffer without a prefixed length, optionally trimmed to a \\nmaximum size.\\n\\nNote: You should ensure the binary format has a way of encoding the\\nbuffers size, as this function writes the buffer raw and doesn\'t write\\nany data a reader can use to determine the size.\\n\\n    ","params":[{"name":"value","desc":"The buffer to write.","lua_type":"buffer"},{"name":"offset","desc":"The starting offset from the buffer.","lua_type":"number?"},{"name":"size","desc":"The amount of bytes from the buffer.","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":519,"path":"lib/init.luau"}},{"name":"write_lbuffer","desc":"Writes a length prefixed buffer.\\n\\n    ","params":[{"name":"value","desc":"The buffer to write.","lua_type":"buffer"},{"name":"offset","desc":"The starting offset from the buffer.","lua_type":"number?"},{"name":"size","desc":"The amount of bytes from the buffer.","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":532,"path":"lib/init.luau"}},{"name":"write_zbuffer","desc":"Writes a null terminated (C Style) buffer.\\n\\nAssumes the buffer is null safe.\\n\\n:::warning\\nThis function doesn\'t check whether the passed value is null-safe, and\\nwill write the entire buffer regardless of embedded null bytes.\\n\\nConsider wrapping the passed value with `byteparse.trim_zbuffer` if you\\ncan\'t be sure there are no embedded null bytes.\\n:::\\n\\n    ","params":[{"name":"value","desc":"The buffer to write.","lua_type":"buffer"},{"name":"offset","desc":"The starting offset from the buffer.","lua_type":"number?"},{"name":"size","desc":"The amount of bytes from the buffer.","lua_type":"number?"}],"returns":[],"function_type":"static","source":{"line":555,"path":"lib/init.luau"}},{"name":"write_array","desc":"Writes a array without a prefixed length.\\n\\nAssumes the encoder function advances the cursor.\\n\\nNote: You should ensure the binary format has a way of encoding the\\narrays size, as this function doesn\'t write any data a reader can use\\nto determine the size.\\n\\n    ","params":[{"name":"value","desc":"The buffer to write.","lua_type":"{T}"},{"name":"encoder","desc":"The encoder function.","lua_type":"(T, B...) -> ()"},{"name":"...","desc":"Additional data to pass to the encoder.","lua_type":"B..."}],"returns":[],"function_type":"static","source":{"line":573,"path":"lib/init.luau"}},{"name":"write_larray","desc":"Writes a length prefixed array.\\n\\nAssumes the encoder function advances the cursor.\\n\\n    ","params":[{"name":"value","desc":"The buffer to write.","lua_type":"{T}"},{"name":"encoder","desc":"The encoder function.","lua_type":"(T, B...) -> ()"},{"name":"...","desc":"Additional data to pass to the encoder.","lua_type":"B..."}],"returns":[],"function_type":"static","source":{"line":588,"path":"lib/init.luau"}},{"name":"write_zarray","desc":"Writes a null terminated array.\\n\\nAssumes the encoder function advances the cursor. The encoder function\\ncan freely emit null bytes **after** the first byte, provided it advances the cursor properly.\\n\\n    ","params":[{"name":"value","desc":"The buffer to write.","lua_type":"{T}"},{"name":"encoder","desc":"The encoder function.","lua_type":"(T, B...) -> ()"},{"name":"...","desc":"Additional data to pass to the encoder.","lua_type":"B..."}],"returns":[],"function_type":"static","source":{"line":603,"path":"lib/init.luau"}},{"name":"write_vector","desc":"Writes a vector.\\n\\n    ","params":[{"name":"value","desc":"The vector to write.","lua_type":"vector"}],"returns":[],"function_type":"static","source":{"line":613,"path":"lib/init.luau"}},{"name":"write_table","desc":"Writes a serialisable table.\\n\\n    ","params":[{"name":"value","desc":"The table to write.","lua_type":"SerialisableTable"}],"returns":[],"function_type":"static","source":{"line":628,"path":"lib/init.luau"}},{"name":"write_any","desc":"Writes any serialisable type, with the Luau TValue prefixed.\\n    ","params":[{"name":"value","desc":"","lua_type":"Serialisable"}],"returns":[],"function_type":"static","source":{"line":660,"path":"lib/init.luau"}}],"properties":[],"types":[],"name":"writer","desc":"writer instance used to serialise to binary formats.\\n\\n    ","source":{"line":203,"path":"lib/init.luau"}}')}}]);